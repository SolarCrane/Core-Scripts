<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="ModuleScript" referent="RBXd6b5159ffc1142bbb0d4be84cd775d2d">
		<Properties>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">IsometricCamera</string>
			<ProtectedString name="Source"><![CDATA[local PlayersService = game:GetService('Players')
local UserInputService = game:GetService('UserInputService')
local RootCameraCreator = require(script.Parent)
local RunService = game:GetService('RunService')


local MODES =
{
	["Locked"] = true;
	["Free"] = true;
}


-- http://www.siggraph.org/education/materials/HyperGraph/raytrace/rayplane_intersection.htm
function RayPlaneIntersection(ray, planeNormal, planeDistanceFromOrigin)
	-- if XZ-plane then planeNormal is always 0,1,0
	planeNormal = planeNormal.unit
	ray = ray.Unit
	-- compute Pn (dot) Rd = Vd and check if Vd == 0 then we know ray is parallel to plane
	local Vd = planeNormal:Dot(ray.Direction)

	-- can increase this a little bit to account for imprecision or very close angles to zero
	if Vd == 0 then -- parallel, no intersection
		return nil
	end

	local V0 = -(planeNormal:Dot(ray.Origin) + planeDistanceFromOrigin)
	local t = V0 / Vd
	if t < 0 then --plane is behind ray origin, and thus there is no intersection
		return nil
	end

	local intersection = ray.Origin + ray.Direction * t
	return intersection
end

local function IsFinite(num)
	return num == num and num ~= 1/0 and num ~= -1/0
end


local MAX_HISTORY_COUNT = 7
local MAX_HISTORY_DURATION = 0.12
local ZERO_VECTOR = Vector3.new(0,0,0)
local UP_VECTOR = Vector3.new(0,1,0)
local XZ_VECTOR = Vector3.new(1,0,1)

local function CreateVelocityCalculator()
	local this = {}

	local history = {}

	function this:AddMovementEvent(position, timestamp)
		local now = tick()
		timestamp  = timestamp or now

		local historyObject = {['position'] = position; ['time'] = timestamp;}

		table.insert(history, historyObject)
		-- NOTE: we could maintain a sorted list but this is easier to read
		table.sort(history, function(a,b) return a['time'] < b['time'] end)
		
		while #history > MAX_HISTORY_COUNT do
			table.remove(history, 1)
		end
		while #history > 0 and history[1]['time'] + MAX_HISTORY_DURATION < now do
			table.remove(history, 1)
		end
	end

	function this:CalculateVelocity()
		local result = ZERO_VECTOR
		if history[1] then
			local count = #history
			local startTime = history[1]['time']
			local startPosition = history[1]['position']

			-- Skip last event because it may have bad data
			if count > 4 then
				count = count - 1
			end

			for i = 2, count do
				local historyObject = history[i]
				local timeDelta = historyObject['time'] - startTime

				if timeDelta > 0 then
					local positionDelta = historyObject['position'] - startPosition
					local velocity = positionDelta / timeDelta

					if result == ZERO_VECTOR then
						result = velocity
					else
						result = (result + velocity) * 0.5
					end
				end
			end
		end
		return result
	end

	function this:Reset()
		history = {}
	end

	return this
end

local function clamp(low, high, num)
	if low <= high then
		return math.min(high, math.max(low, num))
	end
	return num
end

local function dampen(amplitude, targetPosition, startTime, duration)
	local timeDelta = tick() - startTime
	local position = targetPosition - amplitude * math.exp(-timeDelta / duration)
	-- Originally total duration was 6 by changed to 7.7 to make last value jump smoother
	-- and it probably makes Sorcus happier
	if timeDelta > (7.7 * duration) then
		return targetPosition
	end
	return position
end

local function FindFrustrumCornersOnPlaneCurrentCamera()
	local currentCamera = workspace.CurrentCamera
	local viewportSize = currentCamera and currentCamera.ViewportSize
	if currentCamera and viewportSize then
		local topLeftRay = currentCamera:ViewportPointToRay(0, 0, 0)
		local topRightRay = currentCamera:ViewportPointToRay(viewportSize.X, 0, 0)
		local bottomLeftRay = currentCamera:ViewportPointToRay(0, viewportSize.Y, 0)
		local bottomRightRay = currentCamera:ViewportPointToRay(viewportSize.X, viewportSize.Y, 0)
	end
end

local function FindFrustrumCornersOnPlane(camera)
	local currentCamera = workspace.CurrentCamera
	camera = camera or currentCamera
	local viewportSize = currentCamera and currentCamera.ViewportSize
	if camera and currentCamera and viewportSize then

		local topLeftRay = currentCamera:ViewportPointToRay(0, 0, 0)
		local topRightRay = currentCamera:ViewportPointToRay(viewportSize.X, 0, 0)
		local bottomLeftRay = currentCamera:ViewportPointToRay(0, viewportSize.Y, 0)
		local bottomRightRay = currentCamera:ViewportPointToRay(viewportSize.X, viewportSize.Y, 0)
		
		-- If we want to test corners against a different camera, we did to change
		-- the vector space from world space relative to the currentCamera to
		-- world space relative to the test camera
		local transformPointSpaces = CFrame.Angles(0, math.rad(45), 0):inverse() --currentCamera.CoordinateFrame:inverse()--CFrame.new()
		--if currentCamera ~= camera then
		--	local transformPointSpaces = camera.CoordinateFrame * currentCamera.CoordinateFrame:inverse()
		--end
		
		
		local planeHeight = math.abs(camera.Focus.p.Y)
		
		local topLeftPt = transformPointSpaces * RayPlaneIntersection(topLeftRay, UP_VECTOR, planeHeight)
		local topRightPt = transformPointSpaces * RayPlaneIntersection(topRightRay, UP_VECTOR, planeHeight)
		local bottomLeftPt = transformPointSpaces * RayPlaneIntersection(bottomLeftRay, UP_VECTOR, planeHeight)
		local bottomRightPt = transformPointSpaces * RayPlaneIntersection(bottomRightRay, UP_VECTOR, planeHeight)
		
		local centerPt = currentCamera.Focus.p
		
		return topLeftPt, topRightPt, bottomLeftPt, bottomRightPt
	end
end


local function PointsToEdgeOfAABB(boundingRegion, pts)
	local minX = math.huge
	local maxX = -math.huge
	local minZ = math.huge
	local maxZ = -math.huge
	
	for _, pt in pairs(pts) do
		minX = math.min(minX, pt.X)
		maxX = math.max(maxX, pt.X)
		minZ = math.min(minZ, pt.Z)
		maxZ = math.max(maxZ, pt.Z)
	end
	
	local boxMin = boundingRegion.CFrame.p - boundingRegion.Size/2
	local boxMax = boundingRegion.CFrame.p + boundingRegion.Size/2
	return boxMin.X - minX, maxX - boxMax.X, boxMin.Z - minZ, maxZ - boxMax.Z
end

local function getMaxZoom(camera, boundingRegion)
	if camera and boundingRegion then
		local halfXWidth = boundingRegion.Size.X/2
		local halfYHeight = boundingRegion.Size.Z/2
		
		local xd = halfXWidth / math.tan(math.rad(camera.FieldOfView) / 2)
		local zd = halfYHeight / math.tan(math.rad(camera.FieldOfView) / 2)

		return math.min(xd, zd)
	end
end

local function constrainPointToFrustum(position, newFocus, newCFrame, regionBounds)
	if newFocus and newCFrame then
		local savedFocus = workspace.CurrentCamera.Focus
		local savedCFrame = workspace.CurrentCamera.CoordinateFrame
		workspace.CurrentCamera.Focus = newFocus
		workspace.CurrentCamera.CoordinateFrame = newCFrame
		
		local pts = {FindFrustrumCornersOnPlane(workspace.CurrentCamera)}
		workspace.CurrentCamera.Focus = savedFocus
		workspace.CurrentCamera.CoordinateFrame = savedCFrame
		if #pts > 0 then
			local distanceFromEdges = {PointsToEdgeOfAABB(regionBounds, pts)}
			if #distanceFromEdges > 0 then
				if distanceFromEdges[1] > 0 then
					position = position + Vector3.new(distanceFromEdges[1], 0, 0)
				end
				if distanceFromEdges[2] > 0 then
					position = position - Vector3.new(distanceFromEdges[2], 0, 0)
				end
				if distanceFromEdges[3] > 0 then
					position = position + Vector3.new(0, 0, distanceFromEdges[3])
				end
				if distanceFromEdges[4] > 0 then
					position = position - Vector3.new(0, 0, distanceFromEdges[4])
				end
			end
		end
	end
	return position
end

local function constrainPointToAABB(position, boundingRegion)
	local boxMin = boundingRegion.CFrame.p - boundingRegion.Size/2
	local boxMax = boundingRegion.CFrame.p + boundingRegion.Size/2

	return Vector3.new(clamp(boxMin.X, boxMax.X, position.X), 0, clamp(boxMin.Z, boxMax.Z, position.Z))
end

local function ScreenToWorldScale(distance)
	local camera = workspace.CurrentCamera
	if camera then
		distance = distance or (camera.CoordinateFrame.p - camera.Focus.p).magnitude
		local aspectRatio = camera.ViewportSize.Y / camera.ViewportSize.X
		local width = 2 * distance * math.tan(math.rad(camera.FieldOfView) / 2)
		local height = aspectRatio * width
		return Vector2.new(width, height) / camera.ViewportSize
	end
	return Vector2.new(0,0)
end


local function CreateIsometricCamera()
	local module = RootCameraCreator()

	module.ZoomEnabled = true
	module.PanEnabled = true
	module.KeyPanEnabled = true

	local pitch = math.rad(-55)
	local roll = math.rad(0)
	local yaw = math.rad(45)
	
	local regionBounds = Region3.new(Vector3.new(-300, 0, -300), Vector3.new(300, 0, 300))
	local freeSubjectPosition = Vector3.new()
	local panSensitivity = 2.5
	local mouseRotateSensitivity = 5
	local touchRotateSensitivity = 1

	local mode = "Free"

	local velocityCalculator = CreateVelocityCalculator()
	
	local currentPanRoutine = nil
	
	
	local function setFreeModeFocusPosition(position)	
		--freeSubjectPosition = position
		--local newFocus, newCFrame = module:CalculateCameraCFrame()
		--position = constrainPointToFrustum(position, newFocus, newCFrame, regionBounds)
		
		position = constrainPointToAABB(position, regionBounds)
		freeSubjectPosition = position
	end

	local function onModeChanged(newMode)
		if mode == "Free" then
			local camera = 	workspace.CurrentCamera
			if camera then
				setFreeModeFocusPosition(camera.Focus.p)
			end
		else
			if UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
				UserInputService.MouseBehavior = Enum.MouseBehavior.Default
			end
		end
	end

	function module:SetMode(newMode)
		if MODES[newMode] then
			if newMode ~= mode then
				mode = newMode
				onModeChanged(mode)
			end
		end
	end





	
	--[[
	local superSetCameraZoom = module.SetCameraZoom
	function module:SetCameraZoom(zoom)
		local currentCamera = workspace.CurrentCamera
		local maxZoom = getMaxZoom(currentCamera, regionBounds)
		if maxZoom then
			zoom = math.min(zoom, maxZoom)
		end
		if zoom then
			superSetCameraZoom(self, zoom)
		end
	end
	--]]

	local superGetSubjectPosition = module.GetSubjectPosition
	function module:GetSubjectPosition()
		if mode == "Locked" then
			return superGetSubjectPosition(self)
		end
		local newLookVector = self:ComputerLookVector()

		return freeSubjectPosition
	end
	
	function module:StartVelocityPan(velocity)
		local scaleFactor = .2
		local amplitude = velocity * scaleFactor
		local targetPosition = amplitude
		local duration = 0.25
		local start = tick()
		local currPosition = Vector3.new()
		
		local routine = nil
		routine = coroutine.create(function()
			while currPosition ~= targetPosition and routine == currentPanRoutine do
				local newPosition = dampen(amplitude, targetPosition, start, duration)
				local delta = newPosition - currPosition
				currPosition = newPosition

				local threeDDelta = CFrame.Angles(0, yaw, 0):vectorToWorldSpace(Vector3.new(delta.X, 0, delta.Y)) * Vector3.new(1,0,1)
				setFreeModeFocusPosition(self:GetSubjectPosition() - threeDDelta)
				
				RunService.RenderStepped:wait()
			end
			if routine == currentPanRoutine then
				currentPanRoutine = nil
			end
		end)
		
		currentPanRoutine = routine
		coroutine.resume(routine)
	end
	
	function module:CancelVelocityPan()
		currentPanRoutine = nil
	end

	local InputBeganConn, InputChangedConn, InputEndedConn, TouchRotateConn = nil, nil, nil
	local mouseTrackRoutine = nil
	local superSetEnabled = module.SetEnabled
	
	local mouseButton1Down = false
	local mouseButton2Down = false
	local lastPos = nil
	local freshDelta = false
	
	local function UpdateMouseMovement(input, processed)		
		local position = input.Position
		local currPos = position
		local delta = ZERO_VECTOR
		if lastPos then
			if freshDelta then
				delta = input.Delta
			end
			currPos = lastPos + delta
			lastPos = currPos
			freshDelta = false
		else
			lastPos = position
		end
		
		if mouseButton2Down and not mouseButton1Down then
			local ratio = ScreenToWorldScale()
			if delta ~= ZERO_VECTOR then
				local threeDDelta = CFrame.Angles(0, yaw, 0):vectorToWorldSpace(Vector3.new(delta.X * ratio.X, 0, delta.Y * ratio.Y) * panSensitivity) * XZ_VECTOR
				setFreeModeFocusPosition(module:GetSubjectPosition() - threeDDelta)
			end
			velocityCalculator:AddMovementEvent(currPos, tick())
		elseif mouseButton2Down and mouseButton1Down then
			local ratio = workspace.CurrentCamera and 1 / workspace.CurrentCamera.ViewportSize.X
			if ratio and IsFinite(ratio) then
				local deltaRotation = -delta.X * ratio * mouseRotateSensitivity
				yaw = yaw + deltaRotation
			end
		end
	end
	function module:SetEnabled(newState)
		local wasEnabled = self.Enabled
		superSetEnabled(self, newState)

		if newState ~= wasEnabled then
			if self.Enabled then
				InputBeganConn = UserInputService.InputBegan:connect(function(input, processed)
					if not processed then
						if input.UserInputType == Enum.UserInputType.MouseButton1 then
							mouseButton1Down = true
							velocityCalculator:Reset()
							currentPanRoutine = nil
						elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
							mouseButton2Down = true
							if UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
								UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
							end
							velocityCalculator:Reset()
							currentPanRoutine = nil
						end
					end
				end)
				InputChangedConn = UserInputService.InputChanged:connect(function(input, processed)
					if input.UserInputType == Enum.UserInputType.MouseMovement then
						freshDelta = true
						UpdateMouseMovement(input, processed)
						if mouseTrackRoutine == nil and mouseButton2Down and not mouseButton1Down then
							local routine = nil
							routine = coroutine.create(function()
								while not mouseButton1Down and mouseButton2Down and routine and routine == mouseTrackRoutine do
									UpdateMouseMovement(input, processed)
									RunService.RenderStepped:wait()
								end
								if routine == mouseTrackRoutine then
									mouseTrackRoutine = nil
								end
							end)
							mouseTrackRoutine = routine
							coroutine.resume(routine)
						end
					end
				end)
				InputEndedConn = UserInputService.InputEnded:connect(function(input, processed)
					if input.UserInputType == Enum.UserInputType.MouseButton1 then
						mouseButton1Down = false
					elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
						mouseButton2Down = false
						if UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
							UserInputService.MouseBehavior = Enum.MouseBehavior.Default
						end
						lastPos = nil
						
						local ratio = ScreenToWorldScale()
						local velocity = velocityCalculator:CalculateVelocity() * Vector3.new(ratio.X, ratio.Y, 0) * panSensitivity
						self:StartVelocityPan(velocity)
					end
				end)
				
				-- ROTATE CODE
				local LastRotateValue = nil
				TouchRotateConn = UserInputService.TouchRotate:connect(function(touchPositions, rotation, velocity, state, processed)
					if self.RotateEnabled and not processed then
						if #touchPositions == 2 then
							if LastRotateValue then
								local deltaRotation = rotation - LastRotateValue	
								yaw = yaw + deltaRotation * touchRotateSensitivity
	
								-- update camera because we have moved the camera
								--self:FreePan()
							end
							LastRotateValue = rotation
						end
					end
	
					if state == Enum.UserInputState.End then
						LastRotateValue = nil
					end
				end)
			else
				if InputBeganConn then InputBeganConn:disconnect() InputBeganConn = nil end
				if InputChangedConn then InputChangedConn:disconnect() InputChangedConn = nil end
				lastPos = nil
				if InputEndedConn then InputEndedConn:disconnect() InputEndedConn = nil end
				if TouchRotateConn then TouchRotateConn:disconnect() TouchRotateConn = nil end
				mouseButton1Down = false
				mouseButton2Down = false
				mouseTrackRoutine = false
			end
		end
	end

	function module:ComputerLookVector()
		return (CFrame.Angles(0, yaw, 0) * CFrame.Angles(pitch, 0, 0) * CFrame.Angles(0, 0, roll)).lookVector
	end
	
	function module:CalculateCameraCFrame()
		local player = PlayersService.LocalPlayer

		local subjectPosition = self:GetSubjectPosition()
		if subjectPosition and player then
			local zoom = self:GetCameraZoom()
			if zoom < 0.5 then
				zoom = 0.5
			end
			local newLookVector = self:ComputerLookVector()

			local focus = CFrame.new(subjectPosition)
			local coordinateFrame = CFrame.new(focus.p - (zoom * newLookVector), focus.p)
			return focus, coordinateFrame
		end
	end

--[[
	local part1 = Instance.new('Part')
	part1.Anchored = true
	part1.CanCollide = false
	part1.TopSurface = 'Smooth'
	part1.BottomSurface = 'Smooth'
	part1.FormFactor = 'Custom'
	part1.Size = Vector3.new(1,1,1)
	--part1.Color = Color3.new(1,0,0)
	part1.Parent = workspace
	local selBox = Instance.new('SelectionBox')
	selBox.Adornee = part1
	selBox.Parent = part1
	local part2 = part1:Clone()
	part2.Parent = workspace
	--part2.Color = Color3.new(0,1,0)
	local part3 = part1:Clone()
	part3.Parent = workspace
	--part3.Color = Color3.new(0,0,1)
	local part4 = part1:Clone()
	part4.Parent = workspace
	--part4.Color = Color3.new(1,1,1)
	local parts = {part1, part2, part3, part4}
--]]

	local lastUpdate = tick()
	function module:Update()
		local now = tick()

		local camera = 	workspace.CurrentCamera
		local newFocus, newCFrame = self:CalculateCameraCFrame()
		if camera and newFocus and newCFrame then
			camera.Focus = newFocus
			camera.CoordinateFrame = newCFrame
			self.LastCameraTransform = camera.CoordinateFrame
		end

		lastUpdate = now
		
		
		
		--[[
		if true then
			local corners = {FindFrustrumCornersOnPlane()}
			for i = 1, #corners do
				if parts[i] then
					parts[i].CFrame = CFrame.new(corners[i])
					--parts[i].SelectionBox.Color = parts[i].Color
				end
			end
			local left, right, top, down = PointsToEdgeOfAABB(regionBounds, corners)
			parts[1].CFrame = CFrame.new((corners[1] + corners[3]) / 2 + Vector3.new(left,0,0) / 2)
			parts[1].Size = Vector3.new(left,1,1)
			parts[2].CFrame = CFrame.new((corners[2] + corners[4]) / 2 + Vector3.new(right,0,0) / 2)
			parts[2].Size = Vector3.new(right,1,1)
			parts[3].CFrame = CFrame.new((corners[1] + corners[2]) / 2 + Vector3.new(0,0,top) / 2)
			parts[3].Size = Vector3.new(1,1,top)
			parts[4].CFrame = CFrame.new((corners[3] + corners[4]) / 2 + Vector3.new(0,0,down) / 2)
			parts[4].Size = Vector3.new(1,1,down)
		end
		--]]
	end

	return module
end

return CreateIsometricCamera
]]></ProtectedString>
		</Properties>
	</Item>
</roblox>