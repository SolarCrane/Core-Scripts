<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="ModuleScript" referent="RBXd6b5159ffc1142bbb0d4be84cd775d2d">
		<Properties>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">IsometricCamera</string>
			<ProtectedString name="Source"><![CDATA[local PlayersService = game:GetService('Players')
local UserInputService = game:GetService('UserInputService')
local RootCameraCreator = require(script.Parent)
local RunService = game:GetService('RunService')


local MODES =
{
	["Locked"] = true;
	["Free"] = true;
}


-- http://www.siggraph.org/education/materials/HyperGraph/raytrace/rayplane_intersection.htm
function RayPlaneIntersection(ray, planeNormal, planeDistanceFromOrigin)
	if not ray then print("RayPlaneIntersection: ray is nil") return end
	if not planeNormal then print("RayPlaneIntersection: planeNormal is nil") return end
	if not planeDistanceFromOrigin then print("RayPlaneIntersection: planeDistanceFromOrigin is nil") return end

	-- if XZ-plane then planeNormal is always 0,1,0
	planeNormal = planeNormal.unit
	ray = ray.Unit
	-- compute Pn (dot) Rd = Vd and check if Vd == 0 then we know ray is parallel to plane
	local Vd = planeNormal:Dot(ray.Direction)

	-- can increase this a little bit to account for imprecision or very close angles to zero
	if Vd == 0 then -- parallel, no intersection
		return nil
	end

	local V0 = -(planeNormal:Dot(ray.Origin) + planeDistanceFromOrigin)
	local t = V0 / Vd
	if t < 0 then --plane is behind ray origin, and thus there is no intersection
		return nil
	end

	local intersection = ray.Origin + ray.Direction * t
	return intersection
end


local MAX_HISTORY_COUNT = 7
local MAX_HISTORY_DURATION = 0.12
local ZERO_VECTOR = Vector3.new(0,0,0)
local UP_VECTOR = Vector3.new(0,1,0)

local function CreateVelocityCalculator()
	local this = {}

	local history = {}

	function this:AddMovementEvent(position, timestamp)
		local now = tick()
		timestamp  = timestamp or now

		local historyObject = {['position'] = position; ['time'] = timestamp;}

		table.insert(history, historyObject)
		-- NOTE: we could maintain a sorted list but this is easier to read
		table.sort(history, function(a,b) return a['time'] < b['time'] end)
		
		while #history > MAX_HISTORY_COUNT do
			table.remove(history, 1)
		end
		while #history > 0 and history[1]['time'] + MAX_HISTORY_DURATION < now do
			table.remove(history, 1)
		end
	end

	function this:CalculateVelocity()
		local result = ZERO_VECTOR
		if history[1] then
			local count = #history
			local startTime = history[1]['time']
			local startPosition = history[1]['position']

			-- Skip last event because it may have bad data
			if count > 4 then
				count = count - 1
			end

			for i = 2, count do
				local historyObject = history[i]
				local timeDelta = historyObject['time'] - startTime

				if timeDelta > 0 then
					local positionDelta = historyObject['position'] - startPosition
					local velocity = positionDelta / timeDelta

					if result == ZERO_VECTOR then
						result = velocity
					else
						result = (result + velocity) * 0.5
					end
				end
			end
		end
		return result
	end

	function this:Reset()
		history = {}
	end

	return this
end

local function clamp(low, high, num)
	if low <= high then
		return math.min(high, math.max(low, num))
	end
	return num
end

local function dampen(amplitude, targetPosition, startTime, duration)
	local timeDelta = tick() - startTime
	local position = targetPosition - amplitude * math.exp(-timeDelta / duration)
	-- Originally total duration was 6 by changed to 7.7 to make last value jump smoother
	-- and it probably makes Sorcus happier
	if timeDelta > (7.7 * duration) then
		return targetPosition
	end
	return position
end


local function FindFrustrumCornersOnPlane()
	local camera = workspace.Camera
	if camera then
		local topLeftRay = camera:ViewportPointToRay(0, 0, 0)
		local topRightRay = camera:ViewportPointToRay(camera.ViewportSize.X, 0, 0)
		local bottomLeftRay = camera:ViewportPointToRay(0, camera.ViewportSize.Y, 0)
		local bottomRightRay = camera:ViewportPointToRay(camera.ViewportSize.X, camera.ViewportSize.Y, 0)
		
		local planeHeight = math.abs(camera.Focus.p.Y)
		
		local topLeftPt = RayPlaneIntersection(topLeftRay, UP_VECTOR, planeHeight)
		local topRightPt = RayPlaneIntersection(topRightRay, UP_VECTOR, planeHeight)
		local bottomLeftPt = RayPlaneIntersection(bottomLeftRay, UP_VECTOR, planeHeight)
		local bottomRightPt = RayPlaneIntersection(bottomRightRay, UP_VECTOR, planeHeight)
		
		return topLeftPt, topRightPt, bottomLeftPt, bottomRightPt
	end
end


local function PointsToEdgeOfAABB(boundingRegion, pts)
	local minX = math.huge
	local maxX = -math.huge
	local minZ = math.huge
	local maxZ = -math.huge
	
	for _, pt in pairs(pts) do
		minX = math.min(minX, pt.X)
		maxX = math.max(maxX, pt.X)
		minZ = math.min(minZ, pt.Z)
		maxZ = math.max(maxZ, pt.Z)
	end
	
	local boxMin = boundingRegion.CFrame.p - boundingRegion.Size/2
	local boxMax = boundingRegion.CFrame.p + boundingRegion.Size/2
	
	return boxMin.X - minX, boxMax.X - maxX, boxMin.Z - minZ, boxMax.Z - maxZ	
end


local function ScreenToWorldScale(distance)
	local camera = workspace.Camera
	if camera then
		distance = distance or (camera.CoordinateFrame.p - camera.Focus.p).magnitude
		local aspectRatio = camera.ViewportSize.Y / camera.ViewportSize.X
		local width = 2 * distance * math.tan(math.rad(camera.FieldOfView) / 2)
		local height = aspectRatio * width
		return Vector2.new(width, height) / camera.ViewportSize
	end
	return Vector2.new(0,0)
end


local function CreateIsometricCamera()
	local module = RootCameraCreator()

	module.ZoomEnabled = true
	module.PanEnabled = true
	module.KeyPanEnabled = true

	local pitch = math.rad(-55)
	local roll = math.rad(0)
	local yaw = math.rad(45)
	local regionBounds = Region3.new(Vector3.new(-1e2, 0, -1e2), Vector3.new(1e2, 0, 1e2))
	local freeSubjectPosition = Vector3.new()
	local panSensitivity = 2.5

	local mode = "Free"

	local velocityCalculator = CreateVelocityCalculator()
	
	local currentPanRoutine = nil

	local function setFreeModeFocusPosition(position)
		-- TODO: finish get bounds check the frustrum against the box
		local pts = {FindFrustrumCornersOnPlane()}
		if #pts > 0 then
			local distanceFromEdges = {PointsToEdgeOfAABB(regionBounds, pts)}
			if #distanceFromEdges > 0 then
				print(distanceFromEdges[1], distanceFromEdges[2], distanceFromEdges[3], distanceFromEdges[4])
			end
		end
		
		freeSubjectPosition = position
	end

	local function onModeChanged(newMode)
		if mode == "Free" then
			local camera = 	workspace.CurrentCamera
			if camera then
				setFreeModeFocusPosition(camera.Focus.p)
			end
		else
			if UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
				UserInputService.MouseBehavior = Enum.MouseBehavior.Default
			end
		end
	end

	function module:SetMode(newMode)
		if MODES[newMode] then
			if newMode ~= mode then
				mode = newMode
				onModeChanged(mode)
			end
		end
	end

--[[ -- ROTATE CODE
			self.TouchRotateConn = UserInputService.TouchRotate:connect(function(touchPositions, rotation, velocity, state, processed)
				if self.RotateEnabled and not processed then
					if #touchPositions == 2 then
						if self.LastRotateValue == nil then
							self.LastRotateValue = rotation
						end
						if self.LastRotateValue then
							local deltaRotation = rotation - self.LastRotateValue
							self.LastRotateValue = rotation

							self.CameraYaw = self.CameraYaw + deltaRotation

							-- update camera because we have moved the camera
							self:FreePan()
						end
					end
				end

				if state == Enum.UserInputState.End then
					self.LastRotateValue = nil
				end
			end)
			--]]


	local mouseDown = false
	local lastPos = nil
	local freshDelta = false
	local function UpdateMouse(input, processed)
		if mouseDown then
			local position = input.Position
			if lastPos then
				local delta = freshDelta and input.Delta or Vector3.new()
				local currPos = lastPos + delta
				local ratio = ScreenToWorldScale()
				if freshDelta then
					local threeDDelta = CFrame.Angles(0, yaw, 0):vectorToWorldSpace(Vector3.new(delta.X * ratio.X, 0, delta.Y * ratio.Y) * panSensitivity) * Vector3.new(1,0,1)
					setFreeModeFocusPosition(module:GetSubjectPosition() - threeDDelta)
				end
				velocityCalculator:AddMovementEvent(currPos, tick())
				lastPos = currPos
				freshDelta = false
			else
				lastPos = position
			end
		end
	end


	local superGetSubjectPosition = module.GetSubjectPosition
	function module:GetSubjectPosition()
		if mode == "Locked" then
			return superGetSubjectPosition(self)
		end
		local newLookVector = self:ComputerLookVector()

		return freeSubjectPosition
	end
	
	function module:StartVelocityPan(velocity)
		local scaleFactor = .2
		local amplitude = velocity * scaleFactor
		local targetPosition = amplitude
		local duration = 0.25
		local start = tick()
		local currPosition = Vector3.new()
		
		local routine = nil
		routine = coroutine.create(function()
			while currPosition ~= targetPosition and routine == currentPanRoutine do
				local newPosition = dampen(amplitude, targetPosition, start, duration)
				local delta = newPosition - currPosition
				currPosition = newPosition

				local threeDDelta = CFrame.Angles(0, yaw, 0):vectorToWorldSpace(Vector3.new(delta.X, 0, delta.Y)) * Vector3.new(1,0,1)
				setFreeModeFocusPosition(self:GetSubjectPosition() - threeDDelta)
				
				RunService.RenderStepped:wait()
			end
			if routine == currentPanRoutine then
				currentPanRoutine = nil
			end
		end)
		
		currentPanRoutine = routine
		coroutine.resume(routine)
	end
	
	function module:CancelVelocityPan()
		currentPanRoutine = nil
	end

	local InputBeganConn, InputChangedConn, InputEndedConn = nil, nil, nil
	local mouseTrackRoutine = nil
	local superSetEnabled = module.SetEnabled
	function module:SetEnabled(newState)
		local wasEnabled = self.Enabled
		superSetEnabled(self, newState)

		if newState ~= wasEnabled then
			if self.Enabled then
				InputBeganConn = UserInputService.InputBegan:connect(function(input, processed)
					if input.UserInputType == Enum.UserInputType.MouseButton2 then
						mouseDown = true
						if UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
							UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
						end
						velocityCalculator:Reset()
						currentPanRoutine = nil
					end
				end)
				InputChangedConn = UserInputService.InputChanged:connect(function(input, processed)
					if input.UserInputType == Enum.UserInputType.MouseMovement then
						freshDelta = true
						UpdateMouse(input, processed)
						if mouseTrackRoutine == nil and mouseDown then
							local routine = nil
							routine = coroutine.create(function()
								while mouseDown and routine and routine == mouseTrackRoutine do
									UpdateMouse(input, processed)
									RunService.RenderStepped:wait()
								end
								if routine == mouseTrackRoutine then
									mouseTrackRoutine = nil
								end
							end)
							mouseTrackRoutine = routine
							coroutine.resume(routine)
						end
					end
				end)
				InputEndedConn = UserInputService.InputEnded:connect(function(input, processed)
					if input.UserInputType == Enum.UserInputType.MouseButton2 then
						mouseDown = false
						if UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
							UserInputService.MouseBehavior = Enum.MouseBehavior.Default
						end
						lastPos = nil
						
						local ratio = ScreenToWorldScale()
						local velocity = velocityCalculator:CalculateVelocity() * Vector3.new(ratio.X, ratio.Y, 0) * panSensitivity
						self:StartVelocityPan(velocity)
					end
				end)
			else
				if InputBeganConn then InputBeganConn:disconnect() InputBeganConn = nil end
				if InputChangedConn then InputChangedConn:disconnect() InputChangedConn = nil end
				lastPos = nil
				if InputEndedConn then InputEndedConn:disconnect() InputEndedConn = nil end
				mouseDown = false
				mouseTrackRoutine = false
			end
		end
	end

	function module:ComputerLookVector()
		return (CFrame.Angles(0, yaw, 0) * CFrame.Angles(pitch, 0, 0) * CFrame.Angles(0, 0, roll)).lookVector
	end

	local lastUpdate = tick()
	function module:Update()
		local now = tick()

		local camera = 	workspace.CurrentCamera
		local player = PlayersService.LocalPlayer

		local subjectPosition = self:GetSubjectPosition()
		if subjectPosition and player and camera then
			local zoom = self:GetCameraZoom()
			if zoom < 0.5 then
				zoom = 0.5
			end
			local newLookVector = self:ComputerLookVector()

			camera.Focus = CFrame.new(subjectPosition)
			camera.CoordinateFrame = CFrame.new(camera.Focus.p - (zoom * newLookVector), camera.Focus.p)
			self.LastCameraTransform = camera.CoordinateFrame
		end
		lastUpdate = now
	end

	return module
end

return CreateIsometricCamera
]]></ProtectedString>
		</Properties>
	</Item>
</roblox>